#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include  "robotic_msgs/action/robotic_tasks.hpp"
#include "rclcpp_components/register_node_macro.hpp" 
// #include "robotic_msgs/robotic_msgs/action/robotic_tasks.hpp"
#include "torch/torch.h"
using RoboticTasks = robotic_msgs::action::RoboticTasks;
using namespace std::placeholders;
using RoboticGoalHandle = rclcpp_action::ServerGoalHandle<RoboticTasks>;

namespace RoboticActions
{
class TaskServerNode : public rclcpp::Node 
{
public:
    explicit TaskServerNode(const rclcpp::NodeOptions &options = rclcpp::NodeOptions()) : Node("Task_Server", options) 
    {
        task_server_ = rclcpp_action::create_server<RoboticTasks>(
            this, "task_server", 
            std::bind(&TaskServerNode::goal_callback, this, _1, _2),
            std::bind(&TaskServerNode::goal_cancel, this, _1),
            std::bind(&TaskServerNode::goal_accepted, this, _1)
        );
        RCLCPP_INFO(rclcpp::get_logger("rclcpp"), "Ready to execute the Robotic Actions ...");
    }

private:
    rclcpp_action::Server<RoboticTasks>::SharedPtr task_server_;

    // goal_callback
    rclcpp_action::GoalResponse goal_callback(
        const rclcpp_action::GoalUUID & uuid, std::shared_ptr<const RoboticTasks::Goal> goal) 
        {
        RCLCPP_INFO(this->get_logger(), "Received goal to be executed: %s", goal->task_commands.c_str());
        (void)uuid;
        return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;
        }

    // goal_accepted
    void goal_accepted(const std::shared_ptr<RoboticGoalHandle> goal_handle) {
        std::thread{std::bind(&TaskServerNode::execute, this, _1), goal_handle}.detach();
    }
    // goal_cancel
    rclcpp_action::CancelResponse goal_cancel(const std::shared_ptr<RoboticGoalHandle> goal_handle) {
        auto goal = goal_handle->get_goal();
        RCLCPP_INFO(this->get_logger(), "Received request to cancel goal: %s", goal->task_commands.c_str());
        return rclcpp_action::CancelResponse::ACCEPT;
    }

    // execution
    void execute(const std::shared_ptr<RoboticGoalHandle> goal_handle) {
        RCLCPP_INFO(this->get_logger(), "Executing goal...");
        auto goal = goal_handle->get_goal();
        // Simulate doing the task
        std::this_thread::sleep_for(std::chrono::seconds(2));
        if (rclcpp::ok()) {
            auto result = std::make_shared<robotic_msgs::action::RoboticTasks::Result>();
            // Robot arm manipulation starts from here via Moveit2 library and 
            // robotic sequences are generated by the pytorch model (RT-1)




            result->success = true;
            goal_handle->succeed(result);

            RCLCPP_INFO(rclcpp::get_logger("rclcpp"), "Goal succeeded");
        }
    }
};
}
RCLCPP_COMPONENTS_REGISTER_NODE(RoboticActions::TaskServerNode)